<!-- The first thing you should notice, is that just like our components, these higher-order selectors that we've defined are incomplete and completed to-do's, have no idea how our data is formatted in the redux store. Nowhere here are we referring to state.todos.data or state.todos.isLoading. So, even our higher-order selectors rely on our lower-level selectors, such as getTodos, to worry about the exact format of our data in redux. So, while it might have seemed a little silly beforehand to define a super simple function like getTodos or getTodosLoading, in the long run, it really helps us out. And that's because now, as the number of selectors grows, we won't be referring directly to state.blah-blah-blah in any of our higher-order selectors. So, if at some point we need to change the way our data is formatted in redux, from the point-of-view of our selectors, it'll essentially be a one-line change.  -->

<!--  The second thing, is that the selectors we create with Reselect's createSelector function use something called memoization. So, what on Earth is memoization? Well to put it simply, let's say that we have a function whose output is determined solely by its input. In functional programming, we call these pure functions and all our selectors so far, are good examples of this. Now, if we call a pure function twice in a row with the exact same arguments, it'll give us the exact same result. And because of this fact, if we were to run our entire function again the second time we call it, we'd be completely wasting computational power. Since we could have just saved the result the last time this function was called, and returned that precomputed result when we saw the same arguments were getting passed in. So, with that all in mind, take a look at our getCompletedTodos and getIncompleteTodos functions. The only thing that will change their output is the todos.data array in the redux store. Now granted, at the moment our entire store is still pretty small. But in a full-sized React-Redux application, our to-do's array would likely only be a tiny part of our entire redux store. So, it wouldn't make sense to recompute the completed and incomplete to-do's every single time our component's re-rendered. So, that's one of the nice things that this createSelector function does for us. It makes sure that the parts of the state that it cares about, have actually changed before completely recomputing the result it returns. And this is a somewhat important point to understand. Because on the surface, it might seem like createSelector doesn't really do anything. In other words, it seems like we could replace our getCompletedTodos here, for example, with a function that looks like this. We could say, 

export const getCompletedTodos = state => {
    const { data: todos } = state.todos
    return todos.filter(todo => todo.isCompleted)
},  

On the surface, it looks like using createSelector does exactly the same thing as what we defined here, but it doesn't. If we had just defined getCompletedTodos like this it would recompute every time our app re-rendered, wven if the input and output of this function was exactly the same. When we use createSelector, the return value of this function only changes when the return value of the selectors that we pass as arguments changes. So, anyway, that's just something to keep in mind when working with Reselect. -->